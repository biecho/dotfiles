#!/usr/bin/env python3
"""
exp - Experiment Tracker for Notion

Track experiments across servers with automatic status updates and notifications.

Usage:
    exp init <token>              Initialize with Notion token
    exp track [OPTIONS]           Track experiment (fzf select if no pid)
    exp list                      List tracked experiments
    exp untrack <pid>             Stop tracking a process

Track options:
    --pid, -p PID                 Process ID (or use fzf to select)
    --log, -l PATH                Log file path (auto-detected if not provided)
    --interval, -i SECONDS        Check interval in seconds (default: 30)
    --no-watch                    Don't watch, just register and exit

Examples:
    # Fuzzy select process with fzf (easiest)
    # Forks to background and monitors automatically
    exp track

    # Or specify PID directly (log auto-detected)
    nohup python train.py &> logs/exp.log &
    exp track --pid $!

    # Track with custom interval
    exp track --interval 60

    # Track without background watcher
    exp track --no-watch
"""

import argparse
import json
import os
import re
import subprocess
import sys
import time
from datetime import datetime, timezone
from pathlib import Path
from urllib.request import Request, urlopen
from urllib.error import HTTPError

# === Configuration ===
CONFIG_FILE = Path(os.environ.get("EXP_CONFIG_FILE", Path.home() / ".exp_tracker_config"))
TRACKER_FILE = Path(os.environ.get("EXP_TRACKER_FILE", Path.home() / ".exp_tracker.json"))
DATABASE_ID = "f4e81a8f973c4af594df0928b528c6fa"
NOTIFY_USER_ID = "2e4d872b-594c-81ea-93d4-0002614d2be3"

# === Colors ===
RED, GREEN, YELLOW, BLUE, NC = "\033[31m", "\033[32m", "\033[33m", "\033[34m", "\033[0m"


# === Helpers ===
def load_token() -> str:
    """Load Notion token from config or environment."""
    if CONFIG_FILE.exists():
        match = re.search(r'NOTION_TOKEN="([^"]+)"', CONFIG_FILE.read_text())
        if match:
            return match.group(1)
    if token := os.environ.get("NOTION_TOKEN"):
        return token
    print(f"{RED}Error: NOTION_TOKEN not set. Run: exp init <token>{NC}")
    sys.exit(1)


def load_tracker() -> dict:
    return json.loads(TRACKER_FILE.read_text()) if TRACKER_FILE.exists() else {}


def save_tracker(data: dict):
    TRACKER_FILE.write_text(json.dumps(data, indent=2))


def now_iso() -> str:
    return datetime.now(timezone.utc).strftime("%Y-%m-%dT%H:%M:%S.000Z")


def hostname() -> str:
    return subprocess.run(["hostname"], capture_output=True, text=True).stdout.strip()


def get_command(pid: int) -> str:
    """Get command line from PID."""
    proc_cmdline = Path(f"/proc/{pid}/cmdline")
    if proc_cmdline.exists():
        return proc_cmdline.read_text().replace("\0", " ")[:500]
    r = subprocess.run(["ps", "-p", str(pid), "-o", "args="], capture_output=True, text=True)
    return r.stdout.strip()[:500] if r.returncode == 0 else "unknown"


def is_running(pid: int) -> bool:
    try:
        os.kill(pid, 0)
        return True
    except OSError:
        return False


def format_elapsed(seconds: float) -> str:
    """Format elapsed time as human-readable string."""
    seconds = int(seconds)
    if seconds < 60:
        return f"{seconds}s"
    elif seconds < 3600:
        m, s = divmod(seconds, 60)
        return f"{m}m{s}s"
    else:
        h, rem = divmod(seconds, 3600)
        m = rem // 60
        return f"{h}h{m}m"


def get_process_start_time(pid: int) -> float | None:
    """Get process start time as Unix timestamp."""
    try:
        # Use ps to get process start time
        r = subprocess.run(
            ["ps", "-o", "lstart=", "-p", str(pid)],
            capture_output=True, text=True
        )
        if r.returncode == 0 and r.stdout.strip():
            # Parse the lstart format: "Wed Jan  8 14:30:00 2025"
            from datetime import datetime
            start_str = r.stdout.strip()
            start_dt = datetime.strptime(start_str, "%a %b %d %H:%M:%S %Y")
            return start_dt.timestamp()
    except Exception:
        pass
    return None


def get_descendants(pid: int) -> list[int]:
    """Get all descendant PIDs of a process (children, grandchildren, etc.)."""
    descendants = []
    try:
        # Use pgrep to find direct children
        result = subprocess.run(
            ["pgrep", "-P", str(pid)],
            capture_output=True, text=True
        )
        if result.returncode == 0:
            for child_pid in result.stdout.strip().split("\n"):
                if child_pid:
                    child = int(child_pid)
                    descendants.append(child)
                    # Recursively get grandchildren
                    descendants.extend(get_descendants(child))
    except Exception:
        pass
    return descendants


def is_tree_running(pid: int) -> bool:
    """Check if process or any of its descendants are still running."""
    if is_running(pid):
        return True
    # Parent might have exited but children still running (orphaned to init)
    # This is rare, but check descendants anyway
    for child in get_descendants(pid):
        if is_running(child):
            return True
    return False


def get_children_info(pid: int) -> list[dict]:
    """Get info about all descendant processes."""
    children = []
    for child_pid in get_descendants(pid):
        cmd = get_command(child_pid)
        # Skip shell wrappers and short-lived processes
        if not cmd or cmd.startswith("-bash") or cmd.startswith("-sh"):
            continue
        log = detect_log_file(child_pid)
        children.append({
            "pid": child_pid,
            "cmd": cmd[:200],
            "log": log,
        })
    return children


def get_hottest_log(logs: list[str]) -> tuple[str, str]:
    """Find the most recently modified log file and return (path, content)."""
    if not logs:
        return "", ""

    valid_logs = [(log, Path(log).stat().st_mtime) for log in logs if log and Path(log).exists()]
    if not valid_logs:
        return "", ""

    hottest = max(valid_logs, key=lambda x: x[1])[0]
    return hottest, tail_log(hottest, 15)


def tail_log(path: str, lines: int = 10) -> str:
    r = subprocess.run(["tail", "-n", str(lines), path], capture_output=True, text=True)
    return r.stdout[:2000] if r.returncode == 0 else "(log not found)"


def select_process_fzf() -> int | None:
    """Use fzf to interactively select a process to track."""
    try:
        # Get process list (exclude kernel threads and this script)
        ps = subprocess.run(
            ["ps", "axo", "pid,user,pcpu,pmem,start,command"],
            capture_output=True, text=True
        )
        if ps.returncode != 0:
            return None

        # Filter out header and run through fzf
        lines = ps.stdout.strip().split("\n")
        header = lines[0]
        processes = "\n".join(lines[1:])

        fzf = subprocess.run(
            ["fzf", "--header", f"Select process to track\n{header}",
             "--reverse", "--height=40%", "--border"],
            input=processes,
            capture_output=True, text=True
        )

        if fzf.returncode == 0 and fzf.stdout.strip():
            # PID is first column
            return int(fzf.stdout.split()[0])
    except FileNotFoundError:
        print(f"{YELLOW}fzf not found. Install it or use --pid{NC}")
    except Exception as e:
        print(f"{RED}Error selecting process: {e}{NC}")
    return None


def detect_log_file(pid: int) -> str:
    """Auto-detect log file from process stdout/stderr file descriptors."""
    # Try /proc/PID/fd/ first (Linux)
    for fd in [1, 2]:  # stdout, stderr
        fd_path = Path(f"/proc/{pid}/fd/{fd}")
        if fd_path.exists():
            try:
                target = os.readlink(fd_path)
                # Skip pipes, sockets, terminals
                if not target.startswith(("pipe:", "socket:", "/dev/")):
                    return target
            except OSError:
                pass

    # Fall back to lsof (macOS + Linux)
    try:
        r = subprocess.run(["lsof", "-p", str(pid)], capture_output=True, text=True)
        for line in r.stdout.splitlines()[1:]:  # Skip header
            parts = line.split()
            if len(parts) >= 9:
                fd_col = parts[3]  # e.g., "1w", "2w", "3u"
                # Look for stdout(1), stderr(2), or files open for write
                if fd_col in ("1w", "2w", "1u", "2u") or (fd_col.endswith(("w", "u")) and fd_col[:-1].isdigit()):
                    filepath = parts[-1]
                    if filepath.startswith("/") and not filepath.startswith("/dev/"):
                        return filepath
    except Exception:
        pass

    return ""


# === Notion API ===
def notion(method: str, endpoint: str, token: str, data: dict = None) -> dict:
    req = Request(
        f"https://api.notion.com/v1/{endpoint}",
        data=json.dumps(data).encode() if data else None,
        headers={
            "Authorization": f"Bearer {token}",
            "Content-Type": "application/json",
            "Notion-Version": "2022-06-28",
        },
        method=method,
    )
    try:
        with urlopen(req) as resp:
            return json.loads(resp.read())
    except HTTPError as e:
        return {"error": json.loads(e.read()).get("message", str(e))}


def create_page(token: str, cmd: str, server: str, pid: int, log: str) -> dict:
    return notion("POST", "pages", token, {
        "parent": {"database_id": DATABASE_ID},
        "properties": {
            "Command": {"title": [{"text": {"content": cmd[:200]}, "annotations": {"code": True}}]},
            "Server": {"rich_text": [{"text": {"content": server}, "annotations": {"code": True}}]},
            "Status": {"select": {"name": "Running"}},
            "PID": {"number": pid},
            "Log File": {"rich_text": [{"text": {"content": log}, "annotations": {"code": True}}]},
            "Started": {"date": {"start": now_iso()}},
        },
    })


def update_page(token: str, page_id: str, props: dict) -> dict:
    return notion("PATCH", f"pages/{page_id}", token, {"properties": props})


def clear_page_content(token: str, page_id: str):
    """Remove all content blocks from the page."""
    resp = notion("GET", f"blocks/{page_id}/children", token)
    if "results" in resp:
        for block in resp["results"]:
            notion("DELETE", f"blocks/{block['id']}", token)


def update_content_simple(token: str, page_id: str, log: str) -> dict:
    """Simple content update with just log output (for non-tree tracking)."""
    clear_page_content(token, page_id)
    return notion("PATCH", f"blocks/{page_id}/children", token, {
        "children": [
            {"type": "heading_2", "heading_2": {"rich_text": [{"text": {"content": "Last Log Output"}}]}},
            {"type": "code", "code": {"rich_text": [{"text": {"content": log}}], "language": "plain text"}},
        ]
    })


def update_content_tree(token: str, page_id: str, info: dict) -> dict:
    """Enhanced content update with progress, active processes, and hottest log."""
    clear_page_content(token, page_id)

    pid = info["pid"]
    seen_children = set(info.get("seen_children", []))
    completed = info.get("completed_children", 0)
    failed = info.get("failed_children", 0)

    # Get current children info
    children = get_children_info(pid)
    current_pids = {c["pid"] for c in children}

    # Update seen children
    seen_children.update(current_pids)
    info["seen_children"] = list(seen_children)

    # Calculate progress
    total_seen = len(seen_children)
    running = len(current_pids)

    # Build content blocks
    blocks = []

    # Running time
    start_time = get_process_start_time(pid)
    if start_time:
        elapsed = format_elapsed(time.time() - start_time)
        blocks.extend([
            {"type": "heading_2", "heading_2": {"rich_text": [{"text": {"content": "Status"}}]}},
            {"type": "paragraph", "paragraph": {"rich_text": [{"text": {"content": f"Running for {elapsed}"}}]}},
        ])

    # Progress section
    if total_seen > 0 or completed > 0:
        progress_text = f"{completed}/{total_seen} completed"
        if running > 0:
            progress_text += f" ({running} running"
            if failed > 0:
                progress_text += f", {failed} failed"
            progress_text += ")"
        elif failed > 0:
            progress_text += f" ({failed} failed)"

        blocks.extend([
            {"type": "heading_2", "heading_2": {"rich_text": [{"text": {"content": "Progress"}}]}},
            {"type": "paragraph", "paragraph": {"rich_text": [{"text": {"content": progress_text}}]}},
        ])

    # Active processes section
    if children:
        blocks.append({"type": "heading_2", "heading_2": {"rich_text": [{"text": {"content": f"Active Processes ({len(children)})"}}]}})
        for child in children[:10]:  # Limit to 10 to avoid clutter
            # Shorten command for display
            cmd_short = child["cmd"]
            if len(cmd_short) > 100:
                cmd_short = cmd_short[:100] + "..."
            bullet = f"PID {child['pid']}: {cmd_short}"
            blocks.append({
                "type": "bulleted_list_item",
                "bulleted_list_item": {"rich_text": [{"text": {"content": bullet}}]}
            })
        if len(children) > 10:
            blocks.append({
                "type": "paragraph",
                "paragraph": {"rich_text": [{"text": {"content": f"... and {len(children) - 10} more"}}]}
            })

    # Latest activity section - find hottest log
    all_logs = [info.get("log", "")] + [c["log"] for c in children]
    hottest_path, hottest_content = get_hottest_log(all_logs)

    if hottest_content:
        # Identify which process the log belongs to
        log_source = "parent"
        for child in children:
            if child["log"] == hottest_path:
                log_source = f"PID {child['pid']}"
                break

        blocks.extend([
            {"type": "heading_2", "heading_2": {"rich_text": [{"text": {"content": f"Latest Activity ({log_source})"}}]}},
            {"type": "code", "code": {"rich_text": [{"text": {"content": hottest_content}}], "language": "plain text"}},
        ])
    elif info.get("log"):
        # Fall back to parent log
        parent_log = tail_log(info["log"], 15)
        if parent_log:
            blocks.extend([
                {"type": "heading_2", "heading_2": {"rich_text": [{"text": {"content": "Last Log Output"}}]}},
                {"type": "code", "code": {"rich_text": [{"text": {"content": parent_log}}], "language": "plain text"}},
            ])

    if blocks:
        return notion("PATCH", f"blocks/{page_id}/children", token, {"children": blocks})
    return {}


def add_comment(token: str, page_id: str, msg: str) -> dict:
    return notion("POST", "comments", token, {
        "parent": {"page_id": page_id},
        "rich_text": [
            {"type": "mention", "mention": {"user": {"id": NOTIFY_USER_ID}}},
            {"type": "text", "text": {"content": f" {msg}"}},
        ],
    })


# === Commands ===
def check_child_logs_for_failures(children_logs: list[str]) -> int:
    """Check log files for failure indicators. Returns count of failed."""
    failed = 0
    for log in children_logs:
        if log and Path(log).exists():
            content = tail_log(log, 30)
            if re.search(r"error|exception|traceback|failed|killed|oom", content, re.I):
                failed += 1
    return failed


def check_experiment(token: str, page_id: str, info: dict) -> tuple[bool, dict]:
    """Check a single experiment. Returns (still_running, updated_info)."""
    pid, log, cmd = info["pid"], info.get("log", ""), info.get("cmd", "?")[:40]

    # Initialize child tracking if not present
    if "seen_children" not in info:
        info["seen_children"] = []
        info["completed_children"] = 0
        info["failed_children"] = 0
        info["children_logs"] = {}  # pid -> log path
        info["counted_children"] = []  # children already counted as completed

    seen_children = set(info["seen_children"])
    counted_children = set(info.get("counted_children", []))
    children_logs = info.get("children_logs", {})

    # Get current children
    current_children = get_children_info(pid)
    current_pids = {c["pid"] for c in current_children}

    # Track new children and their logs
    for child in current_children:
        if child["pid"] not in seen_children:
            seen_children.add(child["pid"])
            if child["log"]:
                children_logs[str(child["pid"])] = child["log"]

    # Detect finished children (were seen before, not running now, not yet counted)
    prev_seen = set(info["seen_children"])
    finished_pids = prev_seen - current_pids
    newly_finished = finished_pids - counted_children  # Only count new completions

    # Check finished children for failures
    for finished_pid in newly_finished:
        log_path = children_logs.get(str(finished_pid), "")
        if log_path and Path(log_path).exists():
            content = tail_log(log_path, 30)
            if re.search(r"error|exception|traceback|failed|killed|oom", content, re.I):
                info["failed_children"] = info.get("failed_children", 0) + 1
        info["completed_children"] = info.get("completed_children", 0) + 1
        counted_children.add(finished_pid)

    # Update info
    info["seen_children"] = list(seen_children)
    info["counted_children"] = list(counted_children)
    info["children_logs"] = children_logs

    # Check if tree is still running
    if is_tree_running(pid):
        update_content_tree(token, page_id, info)
        return True, info  # Still running

    # Process tree finished - final check for any remaining failures
    # Count failures for children that finished in this final check
    final_running = current_pids
    for child_pid in seen_children - final_running:
        # These already got counted above via newly_finished, skip
        pass

    # Build completion summary
    total_children = len(seen_children)
    completed = info.get("completed_children", 0)
    failed = info.get("failed_children", 0)
    succeeded = completed - failed

    # Determine overall status
    if failed > 0:
        status, emoji = "Failed", "❌"
    else:
        status, emoji = "Completed", "✅"

    update_page(token, page_id, {
        "Status": {"select": {"name": status}},
        "Finished": {"date": {"start": now_iso()}},
    })

    # Final content update
    update_content_tree(token, page_id, info)

    # Build notification message
    if total_children > 0:
        summary = f"{emoji} {status} on {hostname()}: {cmd}... ({total_children} children: {succeeded} succeeded"
        if failed > 0:
            summary += f", {failed} failed"
        summary += ")"
    else:
        summary = f"{emoji} {status} on {hostname()}: {cmd}..."

    add_comment(token, page_id, summary)

    return False, info  # Finished


def cmd_init(args):
    if not args.token:
        print(f"{RED}Usage: exp init <token>{NC}")
        sys.exit(1)
    CONFIG_FILE.write_text(f'NOTION_TOKEN="{args.token}"\n')
    CONFIG_FILE.chmod(0o600)
    save_tracker({})
    print(f"{GREEN}Initialized!{NC} Config: {CONFIG_FILE}")


def cmd_track(args):
    token = load_token()

    # If no PID provided, use fzf to select
    pid = args.pid
    if not pid:
        pid = select_process_fzf()
        if not pid:
            print(f"{RED}No process selected{NC}")
            sys.exit(1)

    if not is_running(pid):
        print(f"{RED}Error: PID {pid} not running{NC}")
        sys.exit(1)

    # Clean up stale entries and check if already tracked
    tracker = load_tracker()
    stale = [p for p, info in tracker.items() if not is_tree_running(info["pid"])]
    if stale:
        for page_id in stale:
            info = tracker[page_id]
            check_experiment(token, page_id, info)  # Updates Notion with final status
            del tracker[page_id]
        save_tracker(tracker)
        print(f"{YELLOW}Cleaned up {len(stale)} finished experiment(s){NC}")

    for page_id, info in tracker.items():
        if info["pid"] == pid:
            print(f"{YELLOW}Already tracking PID {pid}{NC}")
            print(f"  https://notion.so/{page_id.replace('-', '')}")
            sys.exit(0)

    cmd = get_command(pid)
    server = hostname()

    # Auto-detect log file if not provided
    if args.log:
        log = str(Path(args.log).resolve())
    else:
        log = detect_log_file(pid)
        if log:
            print(f"{GREEN}Auto-detected log:{NC} {log}")

    print(f"{BLUE}Tracking:{NC} {cmd[:60]}...")
    print(f"  Server: {server}, PID: {pid}, Log: {log or '(none)'}")

    resp = create_page(token, cmd, server, pid, log)
    if "error" in resp:
        print(f"{RED}Error: {resp['error']}{NC}")
        sys.exit(1)

    page_id = resp["id"]
    info = {"pid": pid, "log": log, "cmd": cmd[:60], "started_at": time.time()}
    tracker = load_tracker()
    tracker[page_id] = info
    save_tracker(tracker)

    url = f"https://notion.so/{page_id.replace('-', '')}"
    print(f"{GREEN}Tracked!{NC} {url}")

    # Watch mode (default): spawn background watcher
    if not args.no_watch:
        interval = args.interval
        print(f"{BLUE}Watching in background{NC} (checking every {interval}s)...")

        # Spawn detached subprocess to watch
        subprocess.Popen(
            [sys.executable, __file__, "_watch", page_id, str(interval)],
            stdout=subprocess.DEVNULL,
            stderr=subprocess.DEVNULL,
            stdin=subprocess.DEVNULL,
            start_new_session=True,
        )


def cmd_list(args):
    tracker = load_tracker()
    if not tracker:
        print("No experiments tracked.")
        return
    print(f"{BLUE}Tracked experiments:{NC}")
    for page_id, info in tracker.items():
        pid = info["pid"]
        running = is_running(pid)
        if running:
            elapsed = ""
            start_time = get_process_start_time(pid)
            if start_time:
                elapsed = f", {format_elapsed(time.time() - start_time)}"
            status = f"{GREEN}running{elapsed}{NC}"
        else:
            status = f"{RED}stopped{NC}"
        log = info.get("log") or "(none)"
        print(f"  {info.get('cmd', '?')[:50]}...")
        print(f"    PID: {pid} ({status})  Log: {log}")


def cmd_untrack(args):
    if not args.pid:
        print(f"{RED}Usage: exp untrack <pid>{NC}")
        sys.exit(1)
    tracker = load_tracker()
    for page_id, info in list(tracker.items()):
        if info["pid"] == args.pid:
            # Update Notion page status to Cancelled
            token = load_token()
            update_page(token, page_id, {
                "Status": {"select": {"name": "Cancelled"}},
            })
            del tracker[page_id]
            save_tracker(tracker)
            print(f"{GREEN}Removed PID {args.pid} (marked as Cancelled in Notion){NC}")
            return
    print(f"{YELLOW}PID {args.pid} not tracked{NC}")


def cmd_watch_internal(args):
    """Internal: background watcher process."""
    token = load_token()
    page_id = args.page_id
    interval = args.interval
    tracker = load_tracker()

    if page_id not in tracker:
        return

    info = tracker[page_id]
    while True:
        time.sleep(interval)
        still_running, info = check_experiment(token, page_id, info)

        # Persist updated info (child tracking state)
        tracker = load_tracker()
        if page_id in tracker:
            tracker[page_id] = info
            save_tracker(tracker)

        if not still_running:
            tracker = load_tracker()
            tracker.pop(page_id, None)
            save_tracker(tracker)
            break


# === Main ===
def main():
    p = argparse.ArgumentParser(prog="exp", description="Experiment Tracker for Notion")
    sub = p.add_subparsers(dest="cmd")

    sub.add_parser("init", help="Initialize with Notion token").add_argument("token", nargs="?")

    t = sub.add_parser("track", help="Track an experiment (uses fzf if no --pid)")
    t.add_argument("--pid", "-p", type=int, help="Process ID (or use fzf to select)")
    t.add_argument("--log", "-l", help="Log file path (auto-detected if not provided)")
    t.add_argument("--no-watch", action="store_true", help="Don't watch, just register and exit")
    t.add_argument("--interval", "-i", type=int, default=30, help="Check interval in seconds (default: 30)")

    sub.add_parser("list", help="List tracked experiments")
    sub.add_parser("untrack", help="Stop tracking an experiment").add_argument("pid", type=int, nargs="?", help="Process ID to untrack")

    # Internal command for background watcher
    w = sub.add_parser("_watch")
    w.add_argument("page_id")
    w.add_argument("interval", type=int)

    args = p.parse_args()
    {"init": cmd_init, "track": cmd_track, "list": cmd_list, "untrack": cmd_untrack, "_watch": cmd_watch_internal}.get(
        args.cmd, lambda _: p.print_help()
    )(args)


if __name__ == "__main__":
    main()
